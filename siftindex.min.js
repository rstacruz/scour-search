(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.siftindex = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

/**
 * Clones an object but misses a key.
 */

module.exports = function cloneWithoutKeys(object, keys) {
  var result = {};
  for (var k in object) {
    if (object.hasOwnProperty(k) && !keys[k]) {
      result[k] = object[k];
    }
  }
  return result;
};

},{}],2:[function(require,module,exports){
/* eslint-disable no-unused-vars */
'use strict';
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

module.exports = Object.assign || function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (Object.getOwnPropertySymbols) {
			symbols = Object.getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],3:[function(require,module,exports){
'use strict';

function _typeof(obj) { return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj; }

var cloneWithoutKeys = require('./lib/clone_without_keys');
var normalizeKeypath = require('./utilities/normalize_keypath');
var assign = require('object-assign');
var each = require('./utilities/each');
var get = require('./utilities/get');
var stringify = JSON.stringify;

var operands = {};
var indexers = {};
var fallbacks = {};

function si(source, options) {
  if (!(this instanceof si)) return new si(source);
  if (!options) options = {};
  this.data = source;
  this.indices = options.indices || {};
}

si.operands = operands;
si.indexers = indexers;
si.fallbacks = fallbacks;

var indexTypes = ['$eq'];

si.prototype = {
  /**
   * Creates an index for the field `field`.
   */

  index: function index(field, type) {
    var _this = this;

    field = normalizeKeypath(field);
    var indexKey = '' + field.join('.') + ':' + (type || '$eq');
    if (!this.indices[indexKey]) this.indices[indexKey] = {};

    each(this.data, function (value, key) {
      indexers['$eq'](value, key, field, _this.indices[indexKey]);
    });

    return this;
  },

  /**
   * Returns keys matching a given value. Run it through `Object.keys` later.
   *
   *     getKeys('name', 'John') // => { '4': 1, '5': 1 }
   */

  getKeys: function getKeys(field, value, type) {
    var key = '' + field + ':' + (type || '$eq');
    value = stringify(value);
    if (!this.indices[key]) return;

    var result = this.indices[key][value];
    if (typeof result === 'undefined') return {};

    return result;
  },

  /**
   * Performs a query.
   */

  filter: function filter(condition) {
    var _this2 = this;

    var keys = this.filterKeys(condition);
    if (Array.isArray(this.data)) {
      return Object.keys(keys).map(function (key) {
        return _this2.data[key];
      });
    } else {
      var result = {};
      keys.forEach(function (key) {
        result[key] = _this2.data[key];
      });
      return result;
    }
  },

  /**
   * Performs a query.
   */

  filterKeys: function filterKeys(condition) {
    return this.filterAST(toAST(condition));
  },

  /**
   * Performs a query with a given AST.
   */

  filterAST: function filterAST(condition) {
    var result = filter(this, condition);
    return result && Object.keys(result);
  }
};

si.toAST = toAST;

/*
 * { name: 'john' }
 * { name: { $eq: 'john' } }
 */

function toAST(condition, prefix) {
  if ((typeof condition === 'undefined' ? 'undefined' : _typeof(condition)) !== 'object') {
    return { type: '$eq', key: prefix, value: condition };
  }

  var keys = Object.keys(condition);
  var result = {};

  if (keys.length === 1) {
    var operand = operands[keys[0]];
    var value = condition[keys[0]];

    if (operand && operand.unary) {
      return { type: keys[0], key: prefix, value: toAST(value, prefix) };
    } else if (operand) {
      return { type: keys[0], key: prefix, value: condition[keys[0]] };
    }
  }

  var conditions = keys.map(function (key) {
    return toAST(condition[key], prefix ? prefix + '.' + key : key);
  });

  return conditions.length === 1 ? conditions[0] : { type: '$and', value: conditions };
}

function filter(idx, condition) {
  var type = condition.type;
  if (!type) return;

  return operands[type] && operands[type](idx, condition) || fallbacks[type] && fallbacks[type](idx, condition) || undefined;
}

indexers['$eq'] = function (item, key, field, index) {
  var val = stringify(get(item, field));
  if (!index[val]) index[val] = {};
  index[val][key] = 1;
};

operands['$eq'] = function (idx, _ref) {
  var key = _ref.key;
  var value = _ref.value;

  return idx.getKeys(key, value);
};

operands['$or'] = unary(function (idx, _ref2) {
  var value = _ref2.value;

  var result = {};

  for (var i = 0, len = value.length; i < len; i++) {
    var subcon = value[i];
    var keys = filter(idx, subcon);
    if (!keys) return;
    assign(result, keys);
  }

  return result;
});

operands['$and'] = unary(function (idx, _ref3) {
  var value = _ref3.value;

  var result = {};

  var _loop = function _loop() {
    var subcon = value[i];
    var keys = filter(idx, subcon);
    if (!keys) return {
        v: undefined
      };
    if (i === 0) assign(result, keys);else {
      each(result, function (_, key) {
        if (!keys[key]) delete result[key];
      });
    }
  };

  for (var i = 0, len = value.length; i < len; i++) {
    var _ret = _loop();

    if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === "object") return _ret.v;
  }

  return result;
});

operands['$in'] = function (idx, _ref4) {
  var key = _ref4.key;
  var value = _ref4.value;

  return filter(idx, {
    type: '$or',
    value: value.map(function (subvalue) {
      return { type: '$eq', key: key, value: subvalue };
    })
  });
};

operands['$not'] = unary(function (idx, _ref5) {
  var value = _ref5.value;

  var subcon = value;
  var result = filter(idx, subcon);

  return cloneWithoutKeys(idx.data, result);
});

operands['$nin'] = function (idx, _ref6) {
  var key = _ref6.key;
  var value = _ref6.value;

  return filter(idx, {
    type: '$not',
    value: { type: '$in', key: key, value: value }
  });
};

fallbacks['$eq'] = function (idx, _ref7) {
  var key = _ref7.key;
  var value = _ref7.value;

  var results = {};
  value = stringify(value);
  each(idx.data, function (item, _key) {
    if (stringify(get(item, normalizeKeypath(key))) === value) results[_key] = 1;
  });
  return results;
};

function unary(fn) {
  fn.unary = true;
  return fn;
}

module.exports = si;

},{"./lib/clone_without_keys":1,"./utilities/each":4,"./utilities/get":5,"./utilities/normalize_keypath":6,"object-assign":2}],4:[function(require,module,exports){
'use strict';

/**
 * each : each(list, fn)
 * Iterates through `list` (an array or an object). This is useful when dealing
 * with NodeLists like `document.querySelectorAll`.
 */

function each(list, fn) {
  if (!list) return;

  var i;
  var len = list.length;
  var idx;

  if (typeof len === 'number') {
    if (each.native) return each.native.call(list, fn);
    for (i = 0; i < len; i++) {
      fn(list[i], i, i);
    }
  } else {
    idx = 0;
    for (i in list) {
      if (list.hasOwnProperty(i)) fn(list[i], i, idx++);
    }
  }

  return list;
}

each.native = Array.prototype.forEach;

module.exports = each;

},{}],5:[function(require,module,exports){
'use strict';

module.exports = function get(object, keypath) {
  var result = object;

  for (var i = 0, len = keypath.length; i < len; i++) {
    result = result[keypath[i]];
    if (!result) return result;
  }

  return result;
};

},{}],6:[function(require,module,exports){
'use strict';

/**
 * Internal: normalizes a keypath, allowing dot syntax, and normalizing them
 * all to strings.
 *
 *     normalizeKeypath('user.12.name')  // => ['user', '12', 'name']
 *     normalizeKeypath(['user', 12])    // => ['user', 12]
 */

module.exports = function normalizeKeypath(keypath, isArguments) {
  if (!keypath) return [];
  if (typeof keypath === 'string') {
    return keypath.split('.');
  } else if (isArguments && keypath.length === 1) {
    if (Array.isArray(keypath[0])) return keypath[0].map(function (k) {
      return '' + k;
    });
    if (typeof keypath[0] === 'number') return ['' + keypath[0]];
    return ('' + keypath[0]).split('.');
  } else {
    if (isArguments) keypath = Array.prototype.slice.call(keypath);
    return keypath.map(function (k) {
      return '' + k;
    });
  }
};

},{}]},{},[3])(3)
});